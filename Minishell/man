https://tiswww.case.edu/php/chet/readline/readline.html

===================================================================================================
readline - get a line from a user with editing
readline will read a line from the terminal and return it, using prompt as a prompt.  If prompt is NULL or the empty string, no prompt is issued.  The line returned  is  allocated  with  mal‐ loc(3);  the  caller  must  free it when finished.  The line returned has the final newline re‐ moved, so only the text of the line remains.
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

char *readline (const char *prompt);
const char *prompt = "minishell$ ";

Exemple:

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>

int main() {
    char *input;
    input = readline("Enter your name: ");
    printf("Hello, %s!\n", input);
    free(input);
    return 0;
}

Note that in order to use readline(), you will need to link your program with the readline library using the -lreadline flag.
===================================================================================================
Function: void rl_clear_history (void)
    Clear the history list by deleting all of the entries, in the same manner as the History library’s clear_history() function. This differs from clear_history because it frees private data Readline saves in the history list. 

#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

int main() {
    // Add some commands to the history list
    add_history("ls");
    add_history("cd");
    add_history("pwd");

    // Clear the history list
    rl_clear_history();

    // Attempt to recall a command from the history list
    char *command = readline("Enter command: ");
    printf("Command entered: %s\n", command);
    free(command);

    return 0;
}

===================================================================================================
Function: int rl_on_new_line (void)
    Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline. 

In the GNU Readline library for C, the rl_on_new_line function is used to inform the library that the prompt has just been printed on a new line.

When the user presses the Enter key after entering a command, Readline moves the cursor to a new line to display the next prompt. If the current prompt has a continuation prompt (e.g., if the user is entering a multi-line command), Readline will use it to prompt the user for additional input. In this case, the rl_on_new_line function should not be called until the last prompt in the sequence is printed.

When rl_on_new_line is called, it informs the Readline library that the cursor is now at the beginning of a new line. This information is used to correctly position the cursor when the user moves up and down through the command history or when the user uses the Emacs-style editing commands provided by Readline.

#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

int main() {
    char *line;

    // Read lines of input until the user enters "exit"
    while (1) {
        // Get a line of input from the user
        line = readline("Enter a command: ");

        // Check if the user entered "exit"
        if (!strcmp(line, "exit")) {
            break;
        }

        // Do something with the input
        printf("You entered: %s\n", line);

        // Free the memory allocated by Readline
        rl_free(line);

        // Inform Readline that we are starting a new line
        rl_on_new_line();
    }

    return 0;
}

In this example, the rl_on_new_line function is called after the memory allocated by Readline for each input line is freed. This tells Readline that the cursor is at the beginning of a new line, which allows Readline to correctly position the cursor when the user navigates through the command history.

===================================================================================================
Function: void rl_replace_line (const char *text, int clear_undo)
    Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. If clear_undo is non-zero, the undo list associated with the current line is cleared. 

The rl_replace_line function in C is a part of the GNU Readline library. This function is used to replace the entire line currently being edited by the user in the Readline interface with a new line of text.

The function takes a single argument: a const char* that represents the new line to be displayed in the Readline interface. The function replaces the current line of text being edited with the new line of text.

Here is an example usage of rl_replace_line:

#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

int main() {
    char *input;
    input = readline("Enter a line of text: ");
    add_history(input);

    // Replace the current input with a new line of text
    rl_replace_line("This is a new line", 1);

    // Move the cursor to the end of the new line
    rl_on_new_line();

    // Redisplay the new line
    rl_redisplay();

    // Free the memory allocated by Readline
    free(input);

    return 0;
}

In this example, the user is prompted to enter a line of text using the readline function. The entered text is then added to the history using the add_history function.

Next, the rl_replace_line function is called to replace the current line of text with the string "This is a new line". The second argument to rl_replace_line is a flag that specifies whether or not to clear the input line history. In this case, we set the flag to 1 to clear the input history.

The rl_on_new_line function is then called to move the cursor to the end of the new line, and rl_redisplay is used to display the new line.

Finally, the memory allocated by Readline is freed using the free function, and the program exits.
===================================================================================================
If you want the user to be able to get at the line later, (with C-p for example), you must call add_history() to save the line away in a history list of such lines.
add_history (line);
It is preferable to avoid saving empty lines on the history list, since users rarely have a burning need to reuse a blank line. Here is a function which usefully replaces the standard gets() library function, and has the advantage of no static buffer to overflow:

/* A static variable for holding the line. */
static char *line_read = (char *)NULL;

/* Read a string, and return a pointer to it.
   Returns NULL on EOF. */
char *
rl_gets ()
{
  /* If the buffer has already been allocated,
     return the memory to the free pool. */
  if (line_read)
    {
      free (line_read);
      line_read = (char *)NULL;
    }

  /* Get a line from the user. */
  line_read = readline ("");

  /* If the line has any text in it,
     save it on the history. */
  if (line_read && *line_read)
    add_history (line_read);

  return (line_read);
}

===================================================================================================
In C programming, rl_redisplay is a function provided by the readline library that allows the programmer to update the display on the terminal. This function causes the current line to be redisplayed on the terminal, taking into account any modifications that have been made to the input line buffer.

When you use readline to read user input from the terminal, the input line is displayed on the screen. If your program needs to modify the input line, you can use rl_redisplay to update the display with the modified input line.

For example, let's say your program reads input from the user and then adds some prefix to the input before processing it. You can use rl_redisplay to update the display with the modified input line:

#include <stdio.h>
#include <stdlib.h>
#include <readline/readline.h>
#include <readline/history.h>

int main() {
    char *input = readline("Enter some text: ");
    char *modified_input = malloc(strlen(input) + 4); // Add space for prefix
    sprintf(modified_input, "(%s)", input); // Add prefix
    rl_redisplay(); // Update the display
    // Process modified input
    free(input);
    free(modified_input);
    return 0;
}

In this example, rl_redisplay is called after modifying the input line buffer. This causes the modified input line to be redisplayed on the terminal, with the added prefix.

===================================================================================================
access, faccessat, faccessat2 - check user's permissions for a file
access()  checks  whether  the  calling process can access the file pathname.  If pathname is a symbolic link, it is dereferenced.
The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the existence of the file.  R_OK, W_OK, and X_OK test whether the  file  exists  and  grants  read, write, and execute permissions, respectively.

#include <unistd.h>
int access(const char *pathname, int mode);

===================================================================================================
wait3, wait4 - wait for process to change state, BSD style
These functions are nonstandard; in new programs, the use of waitpid(2) or waitid(2) is prefer‐able.

The wait3() and wait4() system calls are similar to waitpid(2),  but  additionally  return  re‐ source usage information about the child in the structure pointed to by rusage.

Other than the use of the rusage argument, the following wait3() call:

    wait3(wstatus, options, rusage);

is equivalent to:

    waitpid(-1, wstatus, options);

Similarly, the following wait4() call:

    wait4(pid, wstatus, options, rusage);

is equivalent to:
    waitpid(pid, wstatus, options);

In  other  words,  wait3()  waits  of any child, while wait4() can be used to select a specific child, or children, on which to wait.  See wait(2) for further details.

If rusage is not NULL, the struct rusage to which it points will be filled with accounting  in‐formation about the child.  See getrusage(2) for details.

===================================================================================================
getcwd, getwd, get_current_dir_name - get current working directory
These  functions  return  a  null-terminated string containing an absolute pathname that is the current working directory of the calling process.  The pathname is returned as the function re‐ sult and via the argument buf, if present.

       The getcwd() function copies an absolute pathname of the current working directory to the array pointed to by buf, which is of length size.

       If the length of the absolute pathname of the current working directory, including  the  termi‐ nating null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE; an applica‐ tion should check for this error, and allocate a larger buffer if necessary.

       As an extension to the POSIX.1-2001 standard, glibc's getcwd() allocates the buffer dynamically using  malloc(3) if buf is NULL.  In this case, the allocated buffer has the length size unless size is zero, when buf is allocated as big as necessary.  The caller  should  free(3)  the  re‐turned buffer.
#include <unistd.h>
char *getcwd(char *buf, size_t size);

===================================================================================================
chdir, fchdir - change working directory
chdir() changes the current working directory of the calling process to the directory specified in path.

#include <unistd.h>
int chdir(const char *path);

===================================================================================================
stat, fstat, lstat, fstatat - get file status
These  functions return information about a file, in the buffer pointed to by statbuf.  No per‐ missions are required on the file itself, but—in the case of stat(), fstatat(), and lstat()—ex‐ ecute  (search)  permission  is required on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about the file pointed to by  pathname;  the  differ‐ ences for fstatat() are described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns in‐ formation about the link itself, not the file that the link refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
	       ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The stat() function in C is used to retrieve file status information like file size, permissions, timestamp, etc. The function takes a filename as input and fills a struct stat with the file's metadata.

If the function is successful, it returns 0, and the struct stat pointed to by buf is filled with information about the file. Otherwise, the function returns -1, indicating an error, and sets the errno variable to indicate the reason for the error.

#include <stdio.h>
#include <sys/stat.h>

int main() {
    struct stat fileStat;
    if (stat("example.txt", &fileStat) == -1) {
        perror("stat");
        return 1;
    }
    printf("File Size: %ld bytes\n", fileStat.st_size);
    printf("Permissions: %o\n", fileStat.st_mode & 0777);
    printf("Last Modified: %s", ctime(&fileStat.st_mtime));
    return 0;
}

The lstat function in C is similar to the stat function, except that it provides information about the symbolic link itself, rather than the file it refers to. The lstat function takes a pathname as input and fills a struct stat with information about the symbolic link.

#include <stdio.h>
#include <sys/stat.h>

int main() {
    struct stat sb;
    if (lstat("/path/to/symlink", &sb) == -1) {
        perror("lstat");
        return 1;
    }
    printf("File size: %ld bytes\n", sb.st_size);
    printf("File mode: %o\n", sb.st_mode & 0777);
    // ...
    return 0;
}

Symbolic links are useful for a variety of reasons. One common use case is when you want to create a shortcut to a file or directory that is located in a different part of the file system. Rather than creating a duplicate copy of the file or directory, which can be wasteful in terms of disk space, you can simply create a symbolic link that points to the original location. This allows you to access the file or directory from the new location without having to move it.

Another common use case for symbolic links is when you want to reference a file or directory that has a long or complicated path. By creating a symbolic link with a shorter, more convenient name, you can make it easier to access the file or directory without having to remember its full path.

===================================================================================================
unlink, unlinkat - delete a name and possibly the file it refers to

       unlink()  deletes  a name from the filesystem.  If that name was the last link to a file and no
       processes have the file open, the file is deleted and the space it was using is made  available
       for reuse.

       If  the  name  was the last link to a file but any processes still have the file open, the file
       will remain in existence until the last file descriptor referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If the name referred to a socket, FIFO, or device, the name for it  is  removed  but  processes
       which have the object open may continue to use it.

===================================================================================================
execve - execute program
       execve()  executes  the  program referred to by pathname.  This causes the program that is cur‐ rently being run by the calling process to be replaced with a new program, with newly  initial‐ized stack, heap, and (initialized and uninitialized) data segments.

       pathname must be either a binary executable, or a script starting with a line of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       argv  is  an  array  of pointers to strings passed to the new program as its command-line argu‐ ments.  By convention, the first of these strings (i.e., argv[0]) should contain  the  filename associated  with the file being executed.  The argv array must be terminated by a NULL pointer.  (Thus, in the new program, argv[argc] will be NULL.)

       envp is an array of pointers to strings, conventionally of the form key=value, which are passed as the environment of the new program.  The envp array must be terminated by a NULL pointer.

       The argument vector and environment can be accessed by the new program's main function, when it is defined as:
           int main(int argc, char *argv[], char *envp[])

       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

===================================================================================================
dup, dup2, dup3 - duplicate a file descriptor

       The  dup()  system  call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.

       After a successful return, the old and new file descriptors may be used interchangeably.   They refer  to the same open file description (see open(2)) and thus share file offset and file sta‐ tus flags; for example, if the file offset is modified by using lseek(2) on one of the file de‐ scriptors, the offset is also changed for the other.

       The  two  file  descriptors  do  not share file descriptor flags (the close-on-exec flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.

   dup2()
       The dup2() system call performs the same task as dup(), but instead of  using  the  lowest-num‐ bered  unused  file  descriptor, it uses the file descriptor number specified in newfd.  If the file descriptor newfd was previously open, it is silently closed before being reused.

       The steps of closing and reusing the file descriptor newfd are performed atomically.   This  is important,  because trying to implement equivalent functionality using close(2) and dup() would be subject to race conditions, whereby newfd might be reused between the two steps.  Such reuse could  happen because the main program is interrupted by a signal handler that allocates a file descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.
       *  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.

===================================================================================================
pipe, pipe2 - create pipe

       pipe() creates a pipe, a unidirectional data channel that can be used for interprocess communi‐ cation.  The array pipefd is used to return two file descriptors referring to the ends  of  the pipe.   pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel  until  it  is  read from the read end of the pipe.  For further details, see pipe(7).

       #include <unistd.h>

       /* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */
       struct fd_pair {
           long fd[2];
       };
       struct fd_pair pipe();

       /* On all other architectures */
       int pipe(int pipefd[2]);

===================================================================================================
opendir, fdopendir - open a directory

       The  opendir()  function  opens a directory stream corresponding to the directory name, and re‐ turns a pointer to the directory stream.  The stream is positioned at the first  entry  in  the directory.

       #include <sys/types.h>
       #include <dirent.h>

       DIR *opendir(const char *name);
       DIR *fdopendir(int fd);


===================================================================================================
readdir - read a directory

       The  readdir() function returns a pointer to a dirent structure representing the next directory entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end  of  the directory stream or if an error occurred.

       In the glibc implementation, the dirent structure is defined as follows:

           struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };

       #include <dirent.h>

       struct dirent *readdir(DIR *dirp);

===================================================================================================
closedir - close a directory

       The closedir() function closes the directory stream associated with dirp.  A successful call to closedir() also closes the underlying file descriptor  associated  with  dirp.   The  directory stream descriptor dirp is not available after this call.

       #include <sys/types.h>

       #include <dirent.h>

       int closedir(DIR *dirp);

===================================================================================================
strerror,  strerrorname_np,  strerrordesc_np, strerror_r, strerror_l - return string describing error number

       The strerror() function returns a pointer to a string that describes the error code  passed  in the  argument  errnum,  possibly using the LC_MESSAGES part of the current locale to select the appropriate language.  (For example, if errnum is EINVAL, the returned description will be "In‐ valid  argument".)  This string must not be modified by the application, but may be modified by a subsequent call to strerror() or strerror_l().  No other  library  function,  including  perror(3), will modify this string.
       #include <string.h>

       char *strerror(int errnum);

===================================================================================================
perror - print a system error message
       The  perror()  function  produces a message on standard error describing the last error encoun‐ tered during a call to a system or library function.

       First (if s is not NULL and *s is not a null byte ('\0')), the argument string  s  is  printed, followed  by  a colon and a blank.  Then an error message corresponding to the current value of errno and a new-line.
       To be of most use, the argument string should include the name of the  function  that  incurred the error.

       The  global  error list sys_errlist[], which can be indexed by errno, can be used to obtain the error message without the newline.  The  largest  message  number  provided  in  the  table  is sys_nerr-1.   Be  careful  when  directly accessing this list, because new error values may not have been added to sys_errlist[].  The use of sys_errlist[] is nowadays  deprecated;  use  str‐ error(3) instead.

       When a system call fails, it usually returns -1 and sets the variable errno to a value describ‐ ing what went wrong.  (These values can be found in  <errno.h>.)   Many  library  functions  do likewise.   The function perror() serves to translate this error code into human-readable form.  Note that errno is undefined after a successful system call or library function call: this call may  well change this variable, even though it succeeds, for example because it internally used some other library function that failed.  Thus, if a failing call is not  immediately  followed by a call to perror(), the value of errno should be saved.
       #include <stdio.h>

       void perror(const char *s);

       #include <errno.h>

       const char * const sys_errlist[];
       int sys_nerr;
       int errno;       /* Not really declared this way; see errno(3) */

Exemple:
    fp = fopen("nonexistent_file.txt", "r");
    if (fp == NULL) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

Output:
fopen: No such file or directory

The error message includes the string we passed to perror() and a human-readable description of the error that caused errno to be set.

perror() is a useful function for debugging and error handling, as it can help you quickly identify the source of errors in your program.
===================================================================================================
isatty - test whether a file descriptor refers to a terminal

The isatty() function tests whether fd is an open file descriptor referring to a terminal.
       #include <unistd.h>

       int isatty(int fd);

Exemple:
    if (isatty(STDIN_FILENO)) {
        printf("Standard input is a terminal device\n");
    } else {
        printf("Standard input is not a terminal device\n");
    }

The output of this program will depend on how it is run. If it is run in a terminal window and input is typed in, the program will output "Standard input is a terminal device". If input is piped in from a file, the program will output "Standard input is not a terminal device".

isatty() can be useful when writing programs that interact with users via a terminal device. For example, a program might use isatty() to determine if it should prompt the user for input or read input from a file.

===================================================================================================
ttyname, ttyname_r - return name of a terminal

       The function ttyname() returns a pointer to the null-terminated pathname of the terminal device that is open on the file descriptor fd, or NULL on error (for example, if fd is  not  connected to  a  terminal).   The return value may point to static data, possibly overwritten by the next call.  The function ttyname_r() stores this pathname in the buffer buf of length buflen.

       The function ttyname() returns a pointer to a pathname on success.  On error, NULL is returned, and  errno  is  set appropriately.  The function ttyname_r() returns 0 on success, and an error number upon error.

       #include <unistd.h>

       char *ttyname(int fd);

       int ttyname_r(int fd, char *buf, size_t buflen);

===================================================================================================
ttyslot - find the slot of the current user's terminal in some file

       The legacy function ttyslot() returns the index of the current user's entry in some file.

       If  successful, this function returns the slot number.  On error (e.g., if none of the file de‐ scriptors 0, 1 or 2 is associated with a terminal that occurs in this data base) it  returns  0 on UNIX V6 and V7 and BSD-like systems, but -1 on System V-like systems.

       #include <unistd.h>       /See NOTES */

       int ttyslot(void);

Exemple:
    int slot = ttyslot();
    if (slot == 0) {
        printf("Terminal not found in utmp file\n");
        exit(EXIT_FAILURE);
    }
    printf("Terminal slot number: %d\n", slot);

In this example, we use ttyslot() to determine the slot number of the user's terminal in the utmp file. If the slot number is zero, indicating that the terminal was not found in the utmp file, we print an error message and exit with a failure status. Otherwise, we print the slot number to the console.

ttyslot() is typically used in conjunction with other functions that access the utmp file, such as getutent(), setutent(), and endutent(), which allow you to read and modify the contents of the file. The utmp file can be a useful resource for programs that need to determine which users are currently logged into the system and on which terminals.


    int slot = ttyslot();
    if (slot == 0) {
        printf("Terminal not found in utmp file\n");
        exit(EXIT_FAILURE);
    }
    printf("Terminal slot number: %d\n", slot);

    setutent();  // start reading the utmp file from the beginning

    struct utmp *entry;
    while ((entry = getutent()) != NULL) {
        if (entry->ut_type == USER_PROCESS && entry->ut_line == slot - 1) {
            printf("User: %s\n", entry->ut_user);
            printf("Terminal: %s\n", entry->ut_line);
            printf("PID: %d\n", entry->ut_pid);
            break;
        }
    }

    endutent();  // close the utmp file

    return 0;

In this example, we first use ttyslot() to determine the slot number of the user's terminal in the utmp file. We then call setutent() to start reading the utmp file from the beginning, and use getutent() in a loop to read each entry in the file.

For each entry, we check if the ut_type field is set to USER_PROCESS (indicating that the entry corresponds to a user session), and if the ut_line field matches the slot number of the user's terminal (minus one, since slot numbers are zero-indexed). If we find a matching entry, we print the user's username, the terminal name, and the process ID of the session.

Finally, we call endutent() to close the utmp file.

===================================================================================================
ioctl - control device

       The ioctl() system call manipulates the underlying device parameters of special files.  In par‐ ticular, many operating characteristics of character special files  (e.g.,  terminals)  may  be controlled with ioctl() requests.  The argument fd must be an open file descriptor.

       The  second  argument  is  a  device-dependent  request code.  The third argument is an untyped pointer to memory.  It's traditionally char *argp (from the days before void *  was  valid  C), and will be so named for this discussion.

       An  ioctl() request has encoded in it whether the argument is an in parameter or out parameter, and the size of the argument argp in bytes.  Macros and defines used in specifying  an  ioctl() request are located in the file <sys/ioctl.h>.  See NOTES.

#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>

int main() {
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) {
        perror("ioctl");
        return 1;
    }

    printf("Terminal size: %d rows x %d columns\n", ws.ws_row, ws.ws_col);

    return 0;
}

In this example, we declare a struct winsize variable ws to hold information about the terminal size. We then call ioctl() with the file descriptor STDOUT_FILENO, the TIOCGWINSZ request (which is used to get the window size), and a pointer to the ws struct. If ioctl() returns -1, indicating an error, we print an error message using perror(). Otherwise, we print the number of rows and columns in the terminal.

===================================================================================================
getenv, secure_getenv - get an environment variable
       The  getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.

       #include <stdlib.h>

       char *getenv(const char *name);

       char *secure_getenv(const char *name);

       The getenv() function returns a pointer to the value in the environment, or NULL if there is no match.

===================================================================================================
       termios,  tcgetattr,  tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow, cfmakeraw, cfgetospeed, cfgetispeed, cfsetispeed, cfsetospeed, cfsetspeed - get and set terminal attributes, line  con‐ trol, get and set baud rate

   Retrieving and changing terminal settings
       tcgetattr() gets the parameters associated with the object referred by fd and  stores  them  in the  termios structure referenced by termios_p.  This function may be invoked from a background process; however, the terminal attributes may be subsequently changed by a foreground process.

       tcsetattr() sets the parameters associated with the terminal (unless support is  required  from the  underlying  hardware  that  is  not  available)  from the termios structure referred to by termios_p.  optional_actions specifies when the changes take effect:

       TCSANOW
              the change occurs immediately.

       TCSADRAIN
              the change occurs after all output written to fd  has  been  transmitted.   This  option should be used when changing parameters that affect output.

       TCSAFLUSH
              the  change occurs after all output written to the object referred by fd has been trans‐ mitted, and all input that has been received but not read will be discarded  before  the change is made.

       #include <termios.h>
       #include <unistd.h>

       int tcgetattr(int fd, struct termios *termios_p);

       int tcsetattr(int fd, int optional_actions,
                     const struct termios *termios_p);

       The  termios  functions describe a general terminal interface that is provided to control asyn‐ chronous communications ports.

   The termios structure
       Many of the functions described here have a termios_p argument that is a pointer to  a  termios structure.  This structure contains at least the following members:

           tcflag_t c_iflag;      /* input modes */
           tcflag_t c_oflag;      /* output modes */
           tcflag_t c_cflag;      /* control modes */
           tcflag_t c_lflag;      /* local modes */
           cc_t     c_cc[NCCS];   /* special characters */

       The  values that may be assigned to these fields are described below.  In the case of the first four bit-mask fields, the definitions of some of the associated flags that may be set  are  ex‐ posed  only  if a specific feature test macro (see feature_test_macros(7)) is defined, as noted in brackets ("[]").

#include <stdio.h>
#include <unistd.h>
#include <termios.h>

int main() {
    struct termios termios_p;

    if (tcgetattr(STDIN_FILENO, &termios_p) == -1) {
        perror("tcgetattr");
        return 1;
    }

    termios_p.c_lflag &= ~(ICANON | ECHO);
    termios_p.c_cc[VMIN] = 1;
    termios_p.c_cc[VTIME] = 0;

    if (tcsetattr(STDIN_FILENO, TCSAFLUSH, &termios_p) == -1) {
        perror("tcsetattr");
        return 1;
    }

    printf("Terminal in raw mode\n");

    return 0;
}

In this example, we declare a struct termios variable termios_p to hold information about the terminal attributes. We then call tcgetattr() with the file descriptor STDIN_FILENO and a pointer to the termios_p struct to get the current terminal attributes. We modify the termios_p struct to set the terminal to raw mode by disabling canonical mode and echoing, and setting the minimum number of characters to read to 1 and the timeout to 0. Finally, we call tcsetattr() with the file descriptor STDIN_FILENO, the TCSAFLUSH action (which flushes both input and output queues), and a pointer to the modified termios_p struct to set the new terminal attributes. 

In canonical mode, the terminal driver buffers all input until a complete line is received, and then sends the entire line to the application for processing. This can be useful in situations where the application needs to process the input line by line or where the input may be too long to fit in a single buffer.

However, in some cases, canonical mode may not be desirable, for example, in applications that require real-time input processing or applications that need to process input character by character. In such cases, non-canonical mode can be used, where input is processed as soon as it is received, without waiting for a complete line.

===================================================================================================
tgetent, tgetflag, tgetnum, tgetstr, tgoto, tputs - direct curses interface to the terminfo capability database 

These routines are included as a conversion aid for programs that use the termcap library. Their parameters are the same and the routines are emulated using the terminfo database. Thus, they can only be used to query the capabilities of entries for which a terminfo entry has been compiled.

The tgetent routine loads the entry for name. It returns 1 on success, 0 if there is no such entry, and -1 if the terminfo database could not be found. The emulation ignores the buffer pointer bp.

The tgetflag routine gets the boolean entry for id, or zero if it is not available.

The tgetnum routine gets the numeric entry for id, or -1 if it is not available.

The tgetstr routine returns the string entry for id, or zero if it is not available. Use tputs to output the returned string. The return value will also be copied to the buffer pointed to by area, and the area value will be updated to point past the null ending this value.

Only the first two characters of the id parameter of tgetflag, tgetnum and tgetstr are compared in lookups.

The tgoto routine instantiates the parameters into the given capability. The output from this routine is to be passed to tputs.

The tputs routine is described on the curs_terminfo(3X) manual page. It can retrieve capabilities by either termcap or terminfo name. 

#include <curses.h>
#include <term.h>

extern char PC;
extern char * UP;
extern char * BC;
extern unsigned ospeed;

int tgetent(char *bp, const char *name);
int tgetflag(char *id);
int tgetnum(char *id);
char *tgetstr(char *id, char **area);
char *tgoto(const char *cap, int col, int row);
int tputs(const char *str, int affcnt, int (*putc)(int)); 

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
tgetflag is a function in the C library for manipulating terminal capabilities. It is used to get a boolean value indicating whether a particular terminal capability is present or not.

The tgetflag function takes a single argument, a string representing the name of the capability to look up. It returns an integer value indicating whether the capability is present or not. Specifically, it returns a non-zero value if the capability is present, and 0 otherwise.

#include <stdio.h>
#include <curses.h>
#include <term.h>

int main() {
    // Get the terminal name or type
    char* term_name = getenv("TERM");

    // Open the terminfo database file
    FILE* term_file = fopen("/usr/share/terminfo", "r");

    // Get the terminal description entry
    char term_buffer[1024];
    if (tgetent(term_buffer, term_name) < 0) {
        printf("Error getting terminal description entry\n");
        return 1;
    }

    // Check for the presence of the "am" capability
    if (tgetflag("am")) {
        printf("Automatic margins capability is present\n");
    } else {
        printf("Automatic margins capability is not present\n");
    }

    return 0;
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
tgetnum is a function in the C library for manipulating terminal capabilities. It is used to get an integer value associated with a particular terminal capability.

The tgetnum function takes a single argument, a string representing the name of the capability to look up. It returns an integer value associated with the capability, or -1 if the capability is not present.

#include <stdio.h>
#include <curses.h>
#include <term.h>

int main() {
    // Get the terminal name or type
    char* term_name = getenv("TERM");

    // Open the terminfo database file
    FILE* term_file = fopen("/usr/share/terminfo", "r");

    // Get the terminal description entry
    char term_buffer[1024];
    if (tgetent(term_buffer, term_name) < 0) {
        printf("Error getting terminal description entry\n");
        return 1;
    }

    // Get the number of columns in the terminal
    int num_columns = tgetnum("cols");
    if (num_columns == -1) {
        printf("Could not determine number of columns in the terminal\n");
    } else {
        printf("Number of columns in the terminal is %d\n", num_columns);
    }

    return 0;
}

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
tgetstr is a function in the C library for manipulating terminal capabilities. It is used to retrieve a string value associated with a particular terminal capability.

The tgetstr function takes two arguments: a string representing the name of the capability to look up, and a pointer to a character array where the string value will be stored. The function returns a pointer to the stored string value, or NULL if the capability is not present.

Here is an example of how to use tgetstr to retrieve the "clear screen" capability for a terminal:

#include <stdio.h>
#include <curses.h>
#include <term.h>

int main() {
    // Get the terminal name or type
    char* term_name = getenv("TERM");

    // Open the terminfo database file
    FILE* term_file = fopen("/usr/share/terminfo", "r");

    // Get the terminal description entry
    char term_buffer[1024];
    if (tgetent(term_buffer, term_name) < 0) {
        printf("Error getting terminal description entry\n");
        return 1;
    }

    // Get the "clear screen" capability
    char clear_screen[1024];
    char* clear_screen_ptr = tgetstr("clear", &clear_screen);
    if (clear_screen_ptr == NULL) {
        printf("Could not get the \"clear screen\" capability\n");
    } else {
        printf("The \"clear screen\" capability is: %s\n", clear_screen);
    }

    return 0;
}

In this example, we use tgetstr to retrieve the "clear screen" capability, using the "clear" capability name. If the capability is present, we print its value. If not, we print an error message.

Note that the value returned by tgetstr is a string containing escape sequences that can be used to manipulate the terminal, such as moving the cursor, changing the color of text, or clearing the screen. These escape sequences are interpreted by the terminal emulator when they are printed to the screen.


+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
In C, tgoto() is a function in the termcap library that generates a cursor positioning sequence, given the row and column arguments. The sequence is returned as a string that can be output to a terminal.

The function takes three arguments:

    *const char cap - A string that specifies the terminal capability being used. This is typically obtained using tgetstr().
    int col - An integer representing the column position where the cursor should be placed.
    int row - An integer representing the row position where the cursor should be placed.

The function returns a pointer to a string that represents the cursor positioning sequence.

#include <termcap.h>
#include <stdio.h>

int main() {
    char buffer[1024];
    char *cursor;
    int row = 10;
    int col = 20;
    const char *cap = tgetstr("cm", &buffer);

    if (cap) {
        cursor = tgoto(cap, col, row);
        printf("Cursor positioning sequence: %s\n", cursor);
    }
    else {
        printf("Terminal capability not found.\n");
    }

    return 0;
}

In this example, tgetstr() is used to obtain the terminal capability for cursor movement (cm). If the capability is found, tgoto() is called with the desired row and column positions. The resulting cursor positioning sequence is printed to the console.

Note that the actual behavior of the cursor positioning sequence will depend on the terminal being used, and may vary between different terminals and operating systems.

+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
The tputs() function in C is used to output the given string to the terminal. It is typically used to send control codes to the terminal for tasks such as setting the terminal's text attributes (bold, underline, color, etc.), moving the cursor around the screen, and clearing the screen.

The tputs() function takes two arguments: the first is a pointer to the string of control codes to be sent to the terminal, and the second is the number of lines affected by the control codes. The second argument is usually set to 1, but can be set to a different value if the control codes affect multiple lines.

Here is an example of using tputs() to move the cursor to a specific location on the screen:

#include <term.h>
#include <stdio.h>

int main() {
    char *move = tgoto(tgetstr("cm", NULL), 10, 10);
    tputs(move, 1, putchar);
    return 0;
}

In this example, the tgetstr() function is used to get the "cm" (cursor movement) capability for the current terminal. This capability allows you to move the cursor to a specific position on the screen.

The tgoto() function takes the "cm" capability and two arguments: the row and column where you want the cursor to be moved. It returns a pointer to a string of control codes that will move the cursor to the specified position.

Finally, the tputs() function is used to output the control codes returned by tgoto() to the terminal. The putchar() function is used as the output function, which means the control codes will be sent to the standard output stream (usually the terminal). The second argument to tputs() is set to 1 to indicate that the control codes only affect one line.

Overall, this example will move the cursor to the 10th row and 10th column on the screen.

===================================================================================================


the shell logical operators &&, ||

https://www.tecmint.com/use-wildcards-to-match-filenames-in-linux/
An asterisk (*) – matches one or more occurrences of any character, including no character.

ls -l l*	

rm *tar*
===================================================================================================
exit code
When you run a command or a script in a terminal, the command or script may exit with a code, known as an "exit code". The exit code is a numeric value that represents the success or failure of the command or script.

An exit code of 0 typically means that the command or script was successful and completed without any errors. Any non-zero exit code generally indicates an error or failure of some kind.

The specific exit code values can vary depending on the command or script being run. Some commonly used exit codes include:

    1: Catch-all for general errors
    2: Incorrect usage or invalid arguments
    126: Permission issues preventing execution
    127: Command not found
    130: Script terminated by user via Ctrl+C
    137: Script terminated by system due to excessive resource usage

Exit codes are useful for automating and scripting tasks, as they allow you to programmatically determine whether a command or script was successful or not. For example, you could use the exit code in a shell script to determine whether to continue with the next step of a process or to stop and alert the user to an error.

to add the exit code of two commands, you can use the following syntax:
expr $? + $?   # Adds the exit code of the previous two commands

