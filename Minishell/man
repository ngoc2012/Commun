https://tiswww.case.edu/php/chet/readline/readline.html

===================================================================================================
readline - get a line from a user with editing
readline will read a line from the terminal and return it, using prompt as a prompt.  If prompt is NULL or the empty string, no prompt is issued.  The line returned  is  allocated  with  mal‐ loc(3);  the  caller  must  free it when finished.  The line returned has the final newline re‐ moved, so only the text of the line remains.
#include <stdio.h>
#include <readline/readline.h>
#include <readline/history.h>

char *readline (const char *prompt);
const char *prompt = "minishell$ ";

===================================================================================================
Function: void rl_clear_history (void)
    Clear the history list by deleting all of the entries, in the same manner as the History library’s clear_history() function. This differs from clear_history because it frees private data Readline saves in the history list. 

===================================================================================================
Function: int rl_on_new_line (void)
    Tell the update functions that we have moved onto a new (empty) line, usually after outputting a newline. 

===================================================================================================
Function: void rl_replace_line (const char *text, int clear_undo)
    Replace the contents of rl_line_buffer with text. The point and mark are preserved, if possible. If clear_undo is non-zero, the undo list associated with the current line is cleared. 

===================================================================================================
If you want the user to be able to get at the line later, (with C-p for example), you must call add_history() to save the line away in a history list of such lines.
add_history (line);
It is preferable to avoid saving empty lines on the history list, since users rarely have a burning need to reuse a blank line. Here is a function which usefully replaces the standard gets() library function, and has the advantage of no static buffer to overflow:

/* A static variable for holding the line. */
static char *line_read = (char *)NULL;

/* Read a string, and return a pointer to it.
   Returns NULL on EOF. */
char *
rl_gets ()
{
  /* If the buffer has already been allocated,
     return the memory to the free pool. */
  if (line_read)
    {
      free (line_read);
      line_read = (char *)NULL;
    }

  /* Get a line from the user. */
  line_read = readline ("");

  /* If the line has any text in it,
     save it on the history. */
  if (line_read && *line_read)
    add_history (line_read);

  return (line_read);
}

===================================================================================================
access, faccessat, faccessat2 - check user's permissions for a file
access()  checks  whether  the  calling process can access the file pathname.  If pathname is a symbolic link, it is dereferenced.
The mode specifies the accessibility check(s) to be performed, and is either the value F_OK, or a mask consisting of the bitwise OR of one or more of R_OK, W_OK, and X_OK.  F_OK tests for the existence of the file.  R_OK, W_OK, and X_OK test whether the  file  exists  and  grants  read, write, and execute permissions, respectively.

#include <unistd.h>
int access(const char *pathname, int mode);

===================================================================================================
wait3, wait4 - wait for process to change state, BSD style
These functions are nonstandard; in new programs, the use of waitpid(2) or waitid(2) is prefer‐able.

The wait3() and wait4() system calls are similar to waitpid(2),  but  additionally  return  re‐ source usage information about the child in the structure pointed to by rusage.

Other than the use of the rusage argument, the following wait3() call:

    wait3(wstatus, options, rusage);

is equivalent to:

    waitpid(-1, wstatus, options);

Similarly, the following wait4() call:

    wait4(pid, wstatus, options, rusage);

is equivalent to:
    waitpid(pid, wstatus, options);

In  other  words,  wait3()  waits  of any child, while wait4() can be used to select a specific child, or children, on which to wait.  See wait(2) for further details.

If rusage is not NULL, the struct rusage to which it points will be filled with accounting  in‐formation about the child.  See getrusage(2) for details.

===================================================================================================
getcwd, getwd, get_current_dir_name - get current working directory
These  functions  return  a  null-terminated string containing an absolute pathname that is the current working directory of the calling process.  The pathname is returned as the function re‐ sult and via the argument buf, if present.

       The getcwd() function copies an absolute pathname of the current working directory to the array pointed to by buf, which is of length size.

       If the length of the absolute pathname of the current working directory, including  the  termi‐ nating null byte, exceeds size bytes, NULL is returned, and errno is set to ERANGE; an applica‐ tion should check for this error, and allocate a larger buffer if necessary.

       As an extension to the POSIX.1-2001 standard, glibc's getcwd() allocates the buffer dynamically using  malloc(3) if buf is NULL.  In this case, the allocated buffer has the length size unless size is zero, when buf is allocated as big as necessary.  The caller  should  free(3)  the  re‐turned buffer.
#include <unistd.h>
char *getcwd(char *buf, size_t size);

===================================================================================================
chdir, fchdir - change working directory
chdir() changes the current working directory of the calling process to the directory specified in path.

#include <unistd.h>
int chdir(const char *path);

===================================================================================================
stat, fstat, lstat, fstatat - get file status
These  functions return information about a file, in the buffer pointed to by statbuf.  No per‐ missions are required on the file itself, but—in the case of stat(), fstatat(), and lstat()—ex‐ ecute  (search)  permission  is required on all of the directories in pathname that lead to the file.

       stat() and fstatat() retrieve information about the file pointed to by  pathname;  the  differ‐ ences for fstatat() are described below.

       lstat() is identical to stat(), except that if pathname is a symbolic link, then it returns in‐ formation about the link itself, not the file that the link refers to.

       fstat() is identical to stat(), except that the file about which information is to be retrieved is specified by the file descriptor fd.

   The stat structure
       All of these system calls return a stat structure, which contains the following fields:

           struct stat {
               dev_t     st_dev;         /* ID of device containing file */
	       ino_t     st_ino;         /* Inode number */
               mode_t    st_mode;        /* File type and mode */
               nlink_t   st_nlink;       /* Number of hard links */
               uid_t     st_uid;         /* User ID of owner */
               gid_t     st_gid;         /* Group ID of owner */
               dev_t     st_rdev;        /* Device ID (if special file) */
               off_t     st_size;        /* Total size, in bytes */
               blksize_t st_blksize;     /* Block size for filesystem I/O */
               blkcnt_t  st_blocks;      /* Number of 512B blocks allocated */

               /* Since Linux 2.6, the kernel supports nanosecond
                  precision for the following timestamp fields.
                  For the details before Linux 2.6, see NOTES. */

               struct timespec st_atim;  /* Time of last access */
               struct timespec st_mtim;  /* Time of last modification */
               struct timespec st_ctim;  /* Time of last status change */

           #define st_atime st_atim.tv_sec      /* Backward compatibility */
           #define st_mtime st_mtim.tv_sec
           #define st_ctime st_ctim.tv_sec
           };

#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>

int stat(const char *pathname, struct stat *statbuf);
int fstat(int fd, struct stat *statbuf);
int lstat(const char *pathname, struct stat *statbuf);

===================================================================================================
unlink, unlinkat - delete a name and possibly the file it refers to

       unlink()  deletes  a name from the filesystem.  If that name was the last link to a file and no
       processes have the file open, the file is deleted and the space it was using is made  available
       for reuse.

       If  the  name  was the last link to a file but any processes still have the file open, the file
       will remain in existence until the last file descriptor referring to it is closed.

       If the name referred to a symbolic link, the link is removed.

       If the name referred to a socket, FIFO, or device, the name for it  is  removed  but  processes
       which have the object open may continue to use it.

===================================================================================================
execve - execute program
       execve()  executes  the  program referred to by pathname.  This causes the program that is cur‐ rently being run by the calling process to be replaced with a new program, with newly  initial‐ized stack, heap, and (initialized and uninitialized) data segments.

       pathname must be either a binary executable, or a script starting with a line of the form:

           #!interpreter [optional-arg]

       For details of the latter case, see "Interpreter scripts" below.

       argv  is  an  array  of pointers to strings passed to the new program as its command-line argu‐ ments.  By convention, the first of these strings (i.e., argv[0]) should contain  the  filename associated  with the file being executed.  The argv array must be terminated by a NULL pointer.  (Thus, in the new program, argv[argc] will be NULL.)

       envp is an array of pointers to strings, conventionally of the form key=value, which are passed as the environment of the new program.  The envp array must be terminated by a NULL pointer.

       The argument vector and environment can be accessed by the new program's main function, when it is defined as:
           int main(int argc, char *argv[], char *envp[])

       #include <unistd.h>

       int execve(const char *pathname, char *const argv[],
                  char *const envp[]);

===================================================================================================
dup, dup2, dup3 - duplicate a file descriptor

       The  dup()  system  call creates a copy of the file descriptor oldfd, using the lowest-numbered unused file descriptor for the new descriptor.

       After a successful return, the old and new file descriptors may be used interchangeably.   They refer  to the same open file description (see open(2)) and thus share file offset and file sta‐ tus flags; for example, if the file offset is modified by using lseek(2) on one of the file de‐ scriptors, the offset is also changed for the other.

       The  two  file  descriptors  do  not share file descriptor flags (the close-on-exec flag).  The close-on-exec flag (FD_CLOEXEC; see fcntl(2)) for the duplicate descriptor is off.

   dup2()
       The dup2() system call performs the same task as dup(), but instead of  using  the  lowest-num‐ bered  unused  file  descriptor, it uses the file descriptor number specified in newfd.  If the file descriptor newfd was previously open, it is silently closed before being reused.

       The steps of closing and reusing the file descriptor newfd are performed atomically.   This  is important,  because trying to implement equivalent functionality using close(2) and dup() would be subject to race conditions, whereby newfd might be reused between the two steps.  Such reuse could  happen because the main program is interrupted by a signal handler that allocates a file descriptor, or because a parallel thread allocates a file descriptor.

       Note the following points:

       *  If oldfd is not a valid file descriptor, then the call fails, and newfd is not closed.
       *  If oldfd is a valid file descriptor, and newfd has the same value as oldfd, then dup2() does nothing, and returns newfd.

===================================================================================================
pipe, pipe2 - create pipe

       pipe() creates a pipe, a unidirectional data channel that can be used for interprocess communi‐ cation.  The array pipefd is used to return two file descriptors referring to the ends  of  the pipe.   pipefd[0] refers to the read end of the pipe.  pipefd[1] refers to the write end of the pipe.  Data written to the write end of the pipe is buffered by the kernel  until  it  is  read from the read end of the pipe.  For further details, see pipe(7).

       #include <unistd.h>

       /* On Alpha, IA-64, MIPS, SuperH, and SPARC/SPARC64; see NOTES */
       struct fd_pair {
           long fd[2];
       };
       struct fd_pair pipe();

       /* On all other architectures */
       int pipe(int pipefd[2]);

===================================================================================================
opendir, fdopendir - open a directory

       The  opendir()  function  opens a directory stream corresponding to the directory name, and re‐ turns a pointer to the directory stream.  The stream is positioned at the first  entry  in  the directory.

       #include <sys/types.h>
       #include <dirent.h>

       DIR *opendir(const char *name);
       DIR *fdopendir(int fd);


===================================================================================================
readdir - read a directory

       The  readdir() function returns a pointer to a dirent structure representing the next directory entry in the directory stream pointed to by dirp.  It returns NULL on reaching the end  of  the directory stream or if an error occurred.

       In the glibc implementation, the dirent structure is defined as follows:

           struct dirent {
               ino_t          d_ino;       /* Inode number */
               off_t          d_off;       /* Not an offset; see below */
               unsigned short d_reclen;    /* Length of this record */
               unsigned char  d_type;      /* Type of file; not supported
                                              by all filesystem types */
               char           d_name[256]; /* Null-terminated filename */
           };

       #include <dirent.h>

       struct dirent *readdir(DIR *dirp);

===================================================================================================
closedir - close a directory

       The closedir() function closes the directory stream associated with dirp.  A successful call to closedir() also closes the underlying file descriptor  associated  with  dirp.   The  directory stream descriptor dirp is not available after this call.

       #include <sys/types.h>

       #include <dirent.h>

       int closedir(DIR *dirp);

===================================================================================================
strerror,  strerrorname_np,  strerrordesc_np, strerror_r, strerror_l - return string describing error number

       The strerror() function returns a pointer to a string that describes the error code  passed  in the  argument  errnum,  possibly using the LC_MESSAGES part of the current locale to select the appropriate language.  (For example, if errnum is EINVAL, the returned description will be "In‐ valid  argument".)  This string must not be modified by the application, but may be modified by a subsequent call to strerror() or strerror_l().  No other  library  function,  including  perror(3), will modify this string.
       #include <string.h>

       char *strerror(int errnum);

===================================================================================================
perror - print a system error message
       The  perror()  function  produces a message on standard error describing the last error encoun‐ tered during a call to a system or library function.

       First (if s is not NULL and *s is not a null byte ('\0')), the argument string  s  is  printed, followed  by  a colon and a blank.  Then an error message corresponding to the current value of errno and a new-line.
       To be of most use, the argument string should include the name of the  function  that  incurred the error.

       The  global  error list sys_errlist[], which can be indexed by errno, can be used to obtain the error message without the newline.  The  largest  message  number  provided  in  the  table  is sys_nerr-1.   Be  careful  when  directly accessing this list, because new error values may not have been added to sys_errlist[].  The use of sys_errlist[] is nowadays  deprecated;  use  str‐ error(3) instead.

       When a system call fails, it usually returns -1 and sets the variable errno to a value describ‐ ing what went wrong.  (These values can be found in  <errno.h>.)   Many  library  functions  do likewise.   The function perror() serves to translate this error code into human-readable form.  Note that errno is undefined after a successful system call or library function call: this call may  well change this variable, even though it succeeds, for example because it internally used some other library function that failed.  Thus, if a failing call is not  immediately  followed by a call to perror(), the value of errno should be saved.
       #include <stdio.h>

       void perror(const char *s);

       #include <errno.h>

       const char * const sys_errlist[];
       int sys_nerr;
       int errno;       /* Not really declared this way; see errno(3) */

Exemple:
    fp = fopen("nonexistent_file.txt", "r");
    if (fp == NULL) {
        perror("fopen");
        exit(EXIT_FAILURE);
    }

Output:
fopen: No such file or directory

The error message includes the string we passed to perror() and a human-readable description of the error that caused errno to be set.

perror() is a useful function for debugging and error handling, as it can help you quickly identify the source of errors in your program.
===================================================================================================
isatty - test whether a file descriptor refers to a terminal

The isatty() function tests whether fd is an open file descriptor referring to a terminal.
       #include <unistd.h>

       int isatty(int fd);

Exemple:
    if (isatty(STDIN_FILENO)) {
        printf("Standard input is a terminal device\n");
    } else {
        printf("Standard input is not a terminal device\n");
    }

The output of this program will depend on how it is run. If it is run in a terminal window and input is typed in, the program will output "Standard input is a terminal device". If input is piped in from a file, the program will output "Standard input is not a terminal device".

isatty() can be useful when writing programs that interact with users via a terminal device. For example, a program might use isatty() to determine if it should prompt the user for input or read input from a file.

===================================================================================================
ttyname, ttyname_r - return name of a terminal

       The function ttyname() returns a pointer to the null-terminated pathname of the terminal device that is open on the file descriptor fd, or NULL on error (for example, if fd is  not  connected to  a  terminal).   The return value may point to static data, possibly overwritten by the next call.  The function ttyname_r() stores this pathname in the buffer buf of length buflen.

       The function ttyname() returns a pointer to a pathname on success.  On error, NULL is returned, and  errno  is  set appropriately.  The function ttyname_r() returns 0 on success, and an error number upon error.

       #include <unistd.h>

       char *ttyname(int fd);

       int ttyname_r(int fd, char *buf, size_t buflen);

===================================================================================================
ttyslot - find the slot of the current user's terminal in some file

       The legacy function ttyslot() returns the index of the current user's entry in some file.

       If  successful, this function returns the slot number.  On error (e.g., if none of the file de‐ scriptors 0, 1 or 2 is associated with a terminal that occurs in this data base) it  returns  0 on UNIX V6 and V7 and BSD-like systems, but -1 on System V-like systems.

       #include <unistd.h>       /See NOTES */

       int ttyslot(void);

Exemple:
    int slot = ttyslot();
    if (slot == 0) {
        printf("Terminal not found in utmp file\n");
        exit(EXIT_FAILURE);
    }
    printf("Terminal slot number: %d\n", slot);

In this example, we use ttyslot() to determine the slot number of the user's terminal in the utmp file. If the slot number is zero, indicating that the terminal was not found in the utmp file, we print an error message and exit with a failure status. Otherwise, we print the slot number to the console.

ttyslot() is typically used in conjunction with other functions that access the utmp file, such as getutent(), setutent(), and endutent(), which allow you to read and modify the contents of the file. The utmp file can be a useful resource for programs that need to determine which users are currently logged into the system and on which terminals.


    int slot = ttyslot();
    if (slot == 0) {
        printf("Terminal not found in utmp file\n");
        exit(EXIT_FAILURE);
    }
    printf("Terminal slot number: %d\n", slot);

    setutent();  // start reading the utmp file from the beginning

    struct utmp *entry;
    while ((entry = getutent()) != NULL) {
        if (entry->ut_type == USER_PROCESS && entry->ut_line == slot - 1) {
            printf("User: %s\n", entry->ut_user);
            printf("Terminal: %s\n", entry->ut_line);
            printf("PID: %d\n", entry->ut_pid);
            break;
        }
    }

    endutent();  // close the utmp file

    return 0;

In this example, we first use ttyslot() to determine the slot number of the user's terminal in the utmp file. We then call setutent() to start reading the utmp file from the beginning, and use getutent() in a loop to read each entry in the file.

For each entry, we check if the ut_type field is set to USER_PROCESS (indicating that the entry corresponds to a user session), and if the ut_line field matches the slot number of the user's terminal (minus one, since slot numbers are zero-indexed). If we find a matching entry, we print the user's username, the terminal name, and the process ID of the session.

Finally, we call endutent() to close the utmp file.

===================================================================================================
ioctl - control device

       The ioctl() system call manipulates the underlying device parameters of special files.  In par‐ ticular, many operating characteristics of character special files  (e.g.,  terminals)  may  be controlled with ioctl() requests.  The argument fd must be an open file descriptor.

       The  second  argument  is  a  device-dependent  request code.  The third argument is an untyped pointer to memory.  It's traditionally char *argp (from the days before void *  was  valid  C), and will be so named for this discussion.

       An  ioctl() request has encoded in it whether the argument is an in parameter or out parameter, and the size of the argument argp in bytes.  Macros and defines used in specifying  an  ioctl() request are located in the file <sys/ioctl.h>.  See NOTES.

#include <stdio.h>
#include <unistd.h>
#include <sys/ioctl.h>

int main() {
    struct winsize ws;

    if (ioctl(STDOUT_FILENO, TIOCGWINSZ, &ws) == -1) {
        perror("ioctl");
        return 1;
    }

    printf("Terminal size: %d rows x %d columns\n", ws.ws_row, ws.ws_col);

    return 0;
}

In this example, we declare a struct winsize variable ws to hold information about the terminal size. We then call ioctl() with the file descriptor STDOUT_FILENO, the TIOCGWINSZ request (which is used to get the window size), and a pointer to the ws struct. If ioctl() returns -1, indicating an error, we print an error message using perror(). Otherwise, we print the number of rows and columns in the terminal.

===================================================================================================
getenv, secure_getenv - get an environment variable
       The  getenv() function searches the environment list to find the environment variable name, and returns a pointer to the corresponding value string.

       #include <stdlib.h>

       char *getenv(const char *name);

       char *secure_getenv(const char *name);

       The getenv() function returns a pointer to the value in the environment, or NULL if there is no match.

===================================================================================================
       termios,  tcgetattr,  tcsetattr, tcsendbreak, tcdrain, tcflush, tcflow, cfmakeraw, cfgetospeed, cfgetispeed, cfsetispeed, cfsetospeed, cfsetspeed - get and set terminal attributes, line  con‐ trol, get and set baud rate

   Retrieving and changing terminal settings
       tcgetattr() gets the parameters associated with the object referred by fd and  stores  them  in the  termios structure referenced by termios_p.  This function may be invoked from a background process; however, the terminal attributes may be subsequently changed by a foreground process.

       tcsetattr() sets the parameters associated with the terminal (unless support is  required  from the  underlying  hardware  that  is  not  available)  from the termios structure referred to by termios_p.  optional_actions specifies when the changes take effect:

       TCSANOW
              the change occurs immediately.

       TCSADRAIN
              the change occurs after all output written to fd  has  been  transmitted.   This  option should be used when changing parameters that affect output.

       TCSAFLUSH
              the  change occurs after all output written to the object referred by fd has been trans‐ mitted, and all input that has been received but not read will be discarded  before  the change is made.

       #include <termios.h>
       #include <unistd.h>

       int tcgetattr(int fd, struct termios *termios_p);

       int tcsetattr(int fd, int optional_actions,
                     const struct termios *termios_p);

       The  termios  functions describe a general terminal interface that is provided to control asyn‐ chronous communications ports.

   The termios structure
       Many of the functions described here have a termios_p argument that is a pointer to  a  termios structure.  This structure contains at least the following members:

           tcflag_t c_iflag;      /* input modes */
           tcflag_t c_oflag;      /* output modes */
           tcflag_t c_cflag;      /* control modes */
           tcflag_t c_lflag;      /* local modes */
           cc_t     c_cc[NCCS];   /* special characters */

       The  values that may be assigned to these fields are described below.  In the case of the first four bit-mask fields, the definitions of some of the associated flags that may be set  are  ex‐ posed  only  if a specific feature test macro (see feature_test_macros(7)) is defined, as noted in brackets ("[]").

